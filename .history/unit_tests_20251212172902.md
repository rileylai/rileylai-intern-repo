# Introduction to Unit Testing with Jest

This document explains why automated testing is important and what challenges I faced when writing my first Jest test.

---

## 1. Why is automated testing important in software development?

Automated testing is important because:

1. It helps catch bugs early before code goes to production.
2. It prevents old features from breaking when new code is added.
3. It gives confidence when refactoring or changing code.
4. It saves time compared to manual testing.
5. It improves overall code quality and reliability.

With tests, developers can make changes more safely.

---

## 2. What did you find challenging when writing your first Jest test?

When writing my first Jest test, I found it challenging to:

1. Understand the Jest syntax such as `describe`, `test`, and `expect`.
2. Know how to structure test files correctly.
3. Decide what should be tested and what should not.
4. Debug failing tests and read error messages.
5. Set up the test environment correctly in the project.

After practicing, these challenges became easier to handle.

---

## Summary

Unit testing with Jest helps ensure code works as expected.  
Although writing the first test can be confusing, it becomes easier with practice and improves development confidence.

---

# Testing React Components with Jest & React Testing Library

This section describes what I learned about testing React components using Jest and React Testing Library.

---

## 3. What are the benefits of using React Testing Library instead of testing implementation details?

Using React Testing Library has several benefits:

1. It focuses on how users interact with the UI.
2. Tests do not depend on internal component logic.
3. Tests are less likely to break when refactoring code.
4. It encourages writing accessible components.
5. Test cases are easier to read and understand.

This makes frontend tests more reliable and practical.

---

## 4. What challenges did you encounter when simulating user interaction?

When testing user interaction, I found some challenges:

1. Learning how to use `fireEvent` or `userEvent`.
2. Knowing when to use `async` and `await`.
3. Selecting the correct elements using queries like `getByText`.
4. Handling state changes after clicking buttons.
5. Debugging tests when the UI did not update as expected.

After practicing, these steps became clearer.

---

## Summary (React Component Testing)

Testing React components helps ensure the UI works correctly for users.  
Although interaction testing was confusing at first, it improved my understanding of component behavior.

---

# Mocking API Calls in Jest

This section explains why mocking API calls is important and what problems I faced when testing asynchronous code.

---

## 5. Why is it important to mock API calls in tests?

Mocking API calls is important because:

1. It avoids making real network requests during tests.
2. Tests run faster and are more stable.
3. Test results are not affected by API failures.
4. It allows testing different API responses easily.
5. It helps focus on component behavior instead of backend logic.

Mocking makes tests more reliable and predictable.

---

## 6. What are some common pitfalls when testing asynchronous code?

When testing async code, I encountered some common issues:

1. Forgetting to use `async` and `await` in tests.
2. Tests finishing before the API promise resolves.
3. Not properly mocking API responses.
4. Confusion between `mockResolvedValue` and `mockRejectedValue`.
5. Tests failing due to timing or state update issues.

After understanding async flow, these problems became easier to fix.

---

## Summary (Mocking API Calls)

Mocking API calls helps test async behavior safely and efficiently.  
Although async testing can be tricky at first, practice improves confidence.
